import { NextRequest, NextResponse } from 'next/server'
import { supabase } from '@/lib/supabase'

// ========================================
// BUSINESS PERFORMANCE DATA API - MYR
// ========================================
// Implements all KPI calculations based on business logic
// Data Sources:
//   - DAILY MODE: bp_daily_summary_myr (MV with pre-aggregated daily KPIs)
//   - QUARTERLY MODE: blue_whale_myr (master table - temporary until monthly MV)
//   - NEW REGISTER: new_register (for new depositor counts)
//   - TARGET: bp_target (for target and forecast values)
// Last Updated: 2025-10-21 14:30:00 - IMPLEMENTED: Daily mode using bp_daily_summary_myr
// ========================================

// ========================================
// HELPER: Get Quarter Months
// ========================================
function getQuarterMonths(quarter: string): string[] {
  const quarterMap: Record<string, string[]> = {
    'Q1': ['January', 'February', 'March'],
    'Q2': ['April', 'May', 'June'],
    'Q3': ['July', 'August', 'September'],
    'Q4': ['October', 'November', 'December']
  }
  return quarterMap[quarter] || []
}

// ========================================
// HELPER: Get Previous Quarter
// ========================================
function getPreviousQuarter(quarter: string): string {
  const quarterMap: Record<string, string> = {
    'Q1': 'Q4',
    'Q2': 'Q1',
    'Q3': 'Q2',
    'Q4': 'Q3'
  }
  return quarterMap[quarter] || 'Q4'
}

// ========================================
// HELPER: Calculate Brand Member Flows (for Sankey)
// LOGIC: User boleh masuk MULTIPLE brands (tidak pakai primary brand)
// ========================================
async function calculateBrandMemberFlows(filters: {
  year: number
  quarter: string
  isDateRange: boolean
  startDate: string
  endDate: string
  quarterMonths: string[]
}) {
  const { year, quarter, isDateRange, startDate, endDate, quarterMonths } = filters
  
  // Determine previous period
  const prevQuarter = getPreviousQuarter(quarter)
  const prevYear = quarter === 'Q1' ? year - 1 : year
  const prevQuarterMonths = getQuarterMonths(prevQuarter)
  
  // STEP 1: Fetch CURRENT period
  let currentQuery = supabase
    .from('blue_whale_myr')
    .select('userkey, line')
    .eq('year', year)
    .gt('deposit_cases', 0)
  
  if (isDateRange && startDate && endDate) {
    currentQuery = currentQuery.gte('date', startDate).lte('date', endDate)
  } else {
    currentQuery = currentQuery.in('month', quarterMonths)
  }
  
  const { data: currentData } = await currentQuery
  
  // STEP 2: Fetch PREVIOUS period
  let prevQuery = supabase
    .from('blue_whale_myr')
    .select('userkey, line')
    .eq('year', prevYear)
    .gt('deposit_cases', 0)
    .in('month', prevQuarterMonths)
  
  const { data: prevData } = await prevQuery
  
  // STEP 3: AUTO-DETECT UNIQUE BRANDS from both periods
  // Current period brands (for display)
  const currentBrandsSet = new Set<string>()
  currentData?.forEach((row: any) => {
    if (row.line && row.line.trim()) {
      currentBrandsSet.add(row.line.trim())
    }
  })
  
  // Previous period brands (for churned calculation)
  const prevBrandsSet = new Set<string>()
  prevData?.forEach((row: any) => {
    if (row.line && row.line.trim()) {
      prevBrandsSet.add(row.line.trim())
    }
  })
  
  // ALL brands (union of both periods for complete flow calculation)
  const allBrandsSet = new Set<string>()
  Array.from(currentBrandsSet).forEach(brand => allBrandsSet.add(brand))
  Array.from(prevBrandsSet).forEach(brand => allBrandsSet.add(brand))
  const BRANDS = Array.from(allBrandsSet).sort()  // Sort alfabetis untuk konsistensi
  
  console.log(`üìä [Sankey] Brands in current period: ${Array.from(currentBrandsSet).sort().join(', ')}`)
  console.log(`üìä [Sankey] Brands in previous period: ${Array.from(prevBrandsSet).sort().join(', ')}`)
  console.log(`üìä [Sankey] All brands (for calculation): ${BRANDS.join(', ')}`)
  
  // STEP 4: Group users by brand (current period)
  // User boleh ada di multiple brands!
  const currentByBrand: Record<string, Set<string>> = {}
  const prevByBrand: Record<string, Set<string>> = {}
  
  BRANDS.forEach(brand => {
    currentByBrand[brand] = new Set()
    prevByBrand[brand] = new Set()
  })
  
  currentData?.forEach((row: any) => {
    if (row.line && BRANDS.includes(row.line)) {
      currentByBrand[row.line].add(row.userkey)
    }
  })
  
  prevData?.forEach((row: any) => {
    if (row.line && BRANDS.includes(row.line)) {
      prevByBrand[row.line].add(row.userkey)
    }
  })
  
  // STEP 4: Calculate flows per brand
  const brandFlows: Record<string, { active: number; retained: number; churned: number }> = {}
  
  BRANDS.forEach(brand => {
    const currentUsers = currentByBrand[brand]
    const prevUsers = prevByBrand[brand]
    
    // Active: unique user di brand ini di current period
    const active = currentUsers.size
    
    // Retained: user di brand ini di current & previous period
    const retained = Array.from(currentUsers).filter(key => prevUsers.has(key)).length
    
    // Churned: user di brand ini di previous period tapi tidak di current period
    const churned = Array.from(prevUsers).filter(key => !currentUsers.has(key)).length
    
    brandFlows[brand] = { active, retained, churned }
  })
  
  // STEP 5: FILTER - Hanya return brands yang ADA DI CURRENT PERIOD (active > 0)
  // Brands yang hanya ada di previous period (churned only) tidak ditampilkan di Sankey
  const currentPeriodBrandFlows: Record<string, { active: number; retained: number; churned: number }> = {}
  
  Object.keys(brandFlows).forEach(brand => {
    if (brandFlows[brand].active > 0) {
      currentPeriodBrandFlows[brand] = brandFlows[brand]
    } else {
      console.log(`üìä [Sankey] Filtered out brand ${brand} - no active members in current period`)
    }
  })
  
  return currentPeriodBrandFlows
}

// ========================================
// HELPER: Calculate Member Metrics (Churn, Retention, Reactivation)
// ========================================
interface MemberMetricsFilters {
  year: number
  quarter: string
  isDateRange: boolean
  startDate: string
  endDate: string
  line: string
  quarterMonths: string[]
  activeMemberCurrent: number
  newDepositor: number
}

async function calculateMemberMetrics(filters: MemberMetricsFilters) {
  try {
    const { year, quarter, isDateRange, startDate, endDate, line, quarterMonths, activeMemberCurrent, newDepositor } = filters
    
    // ========================================
    // STEP 1: Determine Previous Period
    // ========================================
    let prevStartDate = ''
    let prevEndDate = ''
    let prevMonths: string[] = []
    
    if (isDateRange && startDate && endDate) {
      // Date Range Mode: Previous period = same duration before startDate
      const start = new Date(startDate)
      const end = new Date(endDate)
      const durationDays = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))
      
      const prevEnd = new Date(start)
      prevEnd.setDate(prevEnd.getDate() - 1)
      const prevStart = new Date(prevEnd)
      prevStart.setDate(prevStart.getDate() - durationDays + 1)
      
      prevStartDate = prevStart.toISOString().split('T')[0]
      prevEndDate = prevEnd.toISOString().split('T')[0]
      
      console.log(`üìÖ Previous Period (Date Range): ${prevStartDate} to ${prevEndDate}`)
    } else {
      // Quarter Mode: Previous period = previous quarter
      const previousQuarter = getPreviousQuarter(quarter)
      prevMonths = getQuarterMonths(previousQuarter)
      
      console.log(`üìÖ Previous Period (Quarter): ${previousQuarter} (${prevMonths.join(', ')})`)
    }
    
    // ========================================
    // STEP 2: Fetch Current Period Users
    // ========================================
    let currentQuery = supabase
      .from('blue_whale_myr')
      .select('userkey')
      .eq('year', year)
      .gt('deposit_cases', 0)
    
    if (isDateRange && startDate && endDate) {
      currentQuery = currentQuery.gte('date', startDate).lte('date', endDate)
    } else {
      currentQuery = currentQuery.in('month', quarterMonths)
    }
    
    if (line !== 'ALL') {
      currentQuery = currentQuery.eq('line', line)
    }
    
    const { data: currentUsers } = await currentQuery
    const currentUserKeys = new Set((currentUsers || []).map((u: any) => u.userkey).filter(Boolean))
    
    console.log(`üë• Current Period: ${currentUserKeys.size} unique users`)
    
    // ========================================
    // STEP 3: Fetch Previous Period Users
    // ========================================
    let prevQuery = supabase
      .from('blue_whale_myr')
      .select('userkey')
      .gt('deposit_cases', 0)
    
    if (isDateRange && prevStartDate && prevEndDate) {
      prevQuery = prevQuery.gte('date', prevStartDate).lte('date', prevEndDate)
      // Year might change if we cross year boundary
      prevQuery = prevQuery.gte('year', year - 1).lte('year', year)
    } else {
      prevQuery = prevQuery.eq('year', year).in('month', prevMonths)
    }
    
    if (line !== 'ALL') {
      prevQuery = prevQuery.eq('line', line)
    }
    
    const { data: prevUsers } = await prevQuery
    const prevUserKeys = new Set((prevUsers || []).map((u: any) => u.userkey).filter(Boolean))
    
    console.log(`üë• Previous Period: ${prevUserKeys.size} unique users`)
    
    // ========================================
    // STEP 4: Calculate Member Metrics
    // ========================================
    
    // CHURN MEMBER = Users in previous period BUT NOT in current period
    const churnUserKeys = Array.from(prevUserKeys).filter(key => !currentUserKeys.has(key))
    const churnMember = churnUserKeys.length
    
    // RETENTION MEMBER = Users in previous period AND ALSO in current period
    const retentionUserKeys = Array.from(prevUserKeys).filter(key => currentUserKeys.has(key))
    const retentionMember = retentionUserKeys.length
    
    // REACTIVATION MEMBER = Users in current period BUT NOT in previous period AND NOT new depositor
    const newUserKeys = Array.from(currentUserKeys).filter(key => !prevUserKeys.has(key))
    const reactivationMember = Math.max(newUserKeys.length - newDepositor, 0)
    
    console.log('üìä Member Breakdown:', {
      churnMember,
      retentionMember,
      reactivationMember,
      prevPeriodActive: prevUserKeys.size,
      currentPeriodActive: currentUserKeys.size,
      newDepositor: newDepositor
    })
    
    // ========================================
    // STEP 5: Calculate Rates
    // ========================================
    const prevActiveMember = prevUserKeys.size
    
    const churnRate = prevActiveMember > 0 ? (churnMember / prevActiveMember) * 100 : 0
    const retentionRate = prevActiveMember > 0 ? (retentionMember / prevActiveMember) * 100 : 0
    
    // Reactivation Rate = Reactivation Member / Churned Pool (recent churned members)
    // For simplicity, we use previous period active as base
    const reactivationRate = prevActiveMember > 0 ? (reactivationMember / prevActiveMember) * 100 : 0
    
    return {
      churnMember,
      retentionMember,
      reactivationMember,
      churnRate,
      retentionRate,
      reactivationRate,
      prevActiveMember
    }
    
  } catch (error) {
    console.error('‚ùå [calculateMemberMetrics] Error:', error)
    return {
      churnMember: 0,
      retentionMember: 0,
      reactivationMember: 0,
      churnRate: 0,
      retentionRate: 0,
      reactivationRate: 0,
      prevActiveMember: 0
    }
  }
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  
  // Extract filters
  const year = searchParams.get('year') || '2025'
  const quarter = searchParams.get('quarter') || 'Q4'
  const isDateRange = searchParams.get('isDateRange') === 'true'
  const startDate = searchParams.get('startDate')
  const endDate = searchParams.get('endDate')
  const line = searchParams.get('line') || 'ALL' // Brand filter

  console.log('üîç [BP Data API] Request:', { year, quarter, isDateRange, startDate, endDate, line })

  try {
    console.log('‚úÖ [BP Data API] Starting execution...')
    const startTime = Date.now()
    
    // ========================================
    // STEP 1: Build Date Filter
    // ========================================
    let quarterMonths: string[] = []
    
    if (!isDateRange) {
      // Monthly mode: Use quarter
      quarterMonths = getQuarterMonths(quarter)
      console.log('üìÖ [BP Data API] Mode: Quarter/Monthly', { quarter, months: quarterMonths })
    } else {
      console.log('üìÖ [BP Data API] Mode: Date Range (Daily)', { startDate, endDate })
    }

    // ========================================
    // STEP 2: Build Base Query Function
    // ========================================
    // ‚úÖ UPDATED: Use bp_daily_summary_myr for daily mode (isDateRange=true)
    // ‚úÖ UPDATED: Use blue_whale_myr for quarterly mode (until monthly MV created)
    const buildBlueWhaleQuery = () => {
      let query
      
      // ‚úÖ DAILY MODE: Use blue_whale_myr (master table untuk COUNT DISTINCT)
      // ‚ö†Ô∏è CRITICAL: Tidak pakai MV karena Active Member untuk DATE RANGE harus COUNT DISTINCT, bukan SUM!
      if (isDateRange && startDate && endDate) {
        query = supabase.from('blue_whale_myr').select('*')
        query = query.eq('currency', 'MYR')
        query = query.eq('year', parseInt(year))
        query = query.gte('date', startDate).lte('date', endDate)
        
        // Brand/Line filter (if not ALL)
        if (line !== 'ALL') {
          query = query.eq('line', line)
        }
        
        console.log('üìä [BP Data API] Using blue_whale_myr (DAILY MODE - for COUNT DISTINCT)', { line, startDate, endDate })
      } 
      // ‚úÖ QUARTERLY MODE: Use blue_whale_myr master table (temporary until monthly MV)
      else {
        query = supabase.from('blue_whale_myr').select('*')
        query = query.eq('year', parseInt(year))
        query = query.in('month', quarterMonths)
        
        // ‚úÖ CRITICAL: For master table, filter line ONLY if not ALL
        // Master table doesn't have aggregated 'ALL' rows
        if (line !== 'ALL') {
          query = query.eq('line', line)
        }
        
        console.log('üìä [BP Data API] Using blue_whale_myr (QUARTERLY MODE)', { line })
      }
      
      return query
    }

    const buildNewRegisterQuery = () => {
      let query = supabase.from('new_register').select('*')
      
      // CURRENCY FILTER - CRITICAL! (MYR only for this API)
      query = query.eq('currency', 'MYR')
      
      // Year filter
      query = query.eq('year', parseInt(year))
      
      // Date filter
      if (isDateRange && startDate && endDate) {
        // ‚úÖ CRITICAL FIX: new_register uses 'date' column, NOT 'registration_date'
        query = query.gte('date', startDate).lte('date', endDate)
      } else {
        // Quarterly mode: Filter by quarter months
        query = query.in('month', quarterMonths)
      }
      
      // Brand/Line filter
      if (line !== 'ALL') {
        query = query.eq('line', line)
      }
      
      return query
    }

    // ========================================
    // BUILD FULL YEAR QUERIES FOR QUARTERLY CHARTS - USE MV!
    // ========================================
    // For quarterly charts, use MONTHLY SUMMARY MV (pre-aggregated)
    // This prevents timeout when fetching full year data
    const buildMVQueryFullYear = () => {
      let query = supabase
        .from('blue_whale_myr_monthly_summary')
        .select('*')
        .eq('year', parseInt(year))
        .gt('month', 0)  // Exclude rollup (month=0)
      
      if (line !== 'ALL') {
        query = query.eq('line', line)
      } else {
        query = query.eq('line', 'ALL')  // For aggregate charts
      }
      
      return query
    }
    
    // For brand-level charts (GGR Contribution, Retention, etc)
    // Fetch ALL brands (no line filter)
    const buildMVQueryFullYearAllBrands = () => {
      return supabase
        .from('blue_whale_myr_monthly_summary')
        .select('*')
        .eq('year', parseInt(year))
        .gt('month', 0)
        .neq('line', 'ALL')  // Exclude aggregate row, only get individual brands
    }
    
    // ========================================
    // STEP 3: PARALLEL QUERIES
    // ========================================
    console.log('üöÄ [BP Data API] Starting parallel queries...')
    
    // ‚úÖ Query bp_daily_summary_myr untuk CHART (daily trend) kalau daily mode
    let mvDailyChartQuery = null
    if (isDateRange && startDate && endDate) {
      mvDailyChartQuery = supabase
        .from('bp_daily_summary_myr')
        .select('*')
        .eq('currency', 'MYR')
        .eq('year', parseInt(year))
        .gte('date', startDate)
        .lte('date', endDate)
        .eq('line', 'ALL')  // Ambil aggregated row untuk chart
        .order('date', { ascending: true })
    }
    
    const [
      blueWhaleResult,
      newRegisterResult,
      mvFullYearResult,
      mvBrandsResult,
      targetResult,
      mvDailyChartResult
    ] = await Promise.all([
      buildBlueWhaleQuery(),
      buildNewRegisterQuery(),
      buildMVQueryFullYear(),  // For aggregate quarterly charts
      buildMVQueryFullYearAllBrands(),  // For brand-level charts
      supabase
        .from('bp_target')
        .select('*')
        .eq('currency', 'MYR')
        .eq('year', parseInt(year))
        .eq('quarter', quarter)
        .eq('is_active', true),
      mvDailyChartQuery  // For daily chart data (GGR trend per date)
    ])

    const queryTime = Date.now() - startTime
    console.log(`‚è±Ô∏è  [BP Data API] Queries completed in ${queryTime}ms`)

    // Extract data
    const mvDailyChartData = mvDailyChartResult?.data || []
    
    // Check errors
    if (blueWhaleResult.error) {
      console.error('‚ùå Blue Whale Error:', blueWhaleResult.error)
      throw blueWhaleResult.error
    }
    if (newRegisterResult.error) {
      console.error('‚ùå New Register Error:', newRegisterResult.error)
      throw newRegisterResult.error
    }
    if (mvFullYearResult.error) {
      console.error('‚ùå MV Full Year Error:', mvFullYearResult.error)
      throw mvFullYearResult.error
    }
    if (mvBrandsResult.error) {
      console.error('‚ùå MV Brands Error:', mvBrandsResult.error)
      throw mvBrandsResult.error
    }

    const blueWhaleData = blueWhaleResult.data || []
    const newRegisterData = newRegisterResult.data || []
    const mvFullYearData = mvFullYearResult.data || []
    const mvBrandsData = mvBrandsResult.data || []
    const targetDataRaw = targetResult.data || []

    console.log(`üìä [BP Data API] Data loaded: ${blueWhaleData.length} transactions (Q4), ${mvFullYearData.length} monthly aggregates, ${mvBrandsData.length} brand aggregates, ${newRegisterData.length} registrations, ${targetDataRaw.length} targets`)

    // ========================================
    // AGGREGATE TARGET DATA (SUM ALL BRANDS)
    // ========================================
    console.log(`üéØ [BP Data API] Target Query Filters: currency=MYR, year=${year}, quarter=${quarter}`)
    console.log(`üéØ [BP Data API] Target Data (Raw):`, targetDataRaw)
    
    const targetData = {
      target_ggr: targetDataRaw.reduce((sum: number, row: any) => sum + (row.target_ggr || 0), 0),
      target_deposit_amount: targetDataRaw.reduce((sum: number, row: any) => sum + (row.target_deposit_amount || 0), 0),
      target_deposit_cases: targetDataRaw.reduce((sum: number, row: any) => sum + (row.target_deposit_cases || 0), 0),
      target_active_member: targetDataRaw.reduce((sum: number, row: any) => sum + (row.target_active_member || 0), 0),
      forecast_ggr: targetDataRaw.reduce((sum: number, row: any) => sum + (row.forecast_ggr || 0), 0)
    }

    console.log(`üéØ [BP Data API] Aggregated Targets (Summed All Brands):`)
    console.log(`   ‚Üí Target GGR: ${targetData.target_ggr.toLocaleString()}`)
    console.log(`   ‚Üí Target Deposit Amount: ${targetData.target_deposit_amount.toLocaleString()}`)
    console.log(`   ‚Üí Target Deposit Cases: ${targetData.target_deposit_cases.toLocaleString()}`)
    console.log(`   ‚Üí Target Active Member: ${targetData.target_active_member.toLocaleString()}`)
    console.log(`   ‚Üí Forecast GGR: ${targetData.forecast_ggr.toLocaleString()}`)

    // ========================================
    // STEP 4: CALCULATE KPIs
    // ========================================
    console.log('üìä [BP Data API] Calculating KPIs...')

    let activeMember, depositAmount, depositCases, withdrawAmount, withdrawCases, addTransaction, deductTransaction, bonusAmount
    let grossGamingRevenue, netProfit
    let retentionMember = 0, reactivationMember = 0, churnMember = 0
    
    // ‚úÖ DAILY MODE: COUNT DISTINCT dari blue_whale_myr (BUKAN SUM dari MV!)
    // ‚ö†Ô∏è CRITICAL: Active Member untuk DATE RANGE tidak bisa di-SUM dari daily MV
    // Contoh: Oct 15 (user A,B,C) + Oct 16 (user A,B,D) = SUM 200 SALAH! ‚Üí COUNT DISTINCT (A,B,C,D) = 4
    if (isDateRange && startDate && endDate) {
      console.log('üìä [BP Data API] Calculating from blue_whale_myr (DAILY MODE - COUNT DISTINCT for date range)')
      
      // 1. ACTIVE MEMBER = COUNT DISTINCT userkey untuk DATE RANGE
      const activeMemberSet = new Set(
        blueWhaleData
          .filter((row: any) => (row.deposit_cases || 0) > 0)
          .map((row: any) => row.userkey)
          .filter(Boolean)
      )
      activeMember = activeMemberSet.size
      
      // 2. FINANCIAL AGGREGATES (SUM untuk date range - ini BENAR)
      depositAmount = blueWhaleData.reduce((sum: number, row: any) => sum + (parseFloat(row.deposit_amount) || 0), 0)
      depositCases = blueWhaleData.reduce((sum: number, row: any) => sum + (parseInt(row.deposit_cases) || 0), 0)
      withdrawAmount = blueWhaleData.reduce((sum: number, row: any) => sum + (parseFloat(row.withdraw_amount) || 0), 0)
      withdrawCases = blueWhaleData.reduce((sum: number, row: any) => sum + (parseInt(row.withdraw_cases) || 0), 0)
      addTransaction = blueWhaleData.reduce((sum: number, row: any) => sum + (parseFloat(row.add_transaction) || 0), 0)
      deductTransaction = blueWhaleData.reduce((sum: number, row: any) => sum + (parseFloat(row.deduct_transaction) || 0), 0)
      bonusAmount = blueWhaleData.reduce((sum: number, row: any) => sum + (parseFloat(row.bonus) || 0) + (parseFloat(row.add_bonus) || 0), 0)
      
      // 3. CALCULATE GGR & NET PROFIT
      grossGamingRevenue = depositAmount - withdrawAmount
      netProfit = (depositAmount + addTransaction) - (withdrawAmount + deductTransaction)
      
      console.log('‚úÖ [BP Data API] Daily Mode KPIs (COUNT DISTINCT):', {
        activeMember,
        grossGamingRevenue,
        netProfit
      })
    } 
    // ‚úÖ QUARTERLY MODE: Data from blue_whale_myr (raw transactions)
    else {
      console.log('üìä [BP Data API] Aggregating from blue_whale_myr (QUARTERLY MODE)')
      
      // 1. ACTIVE MEMBER = COUNT UNIQUE userkey WHERE deposit_cases > 0
      const activeMemberSet = new Set(
        blueWhaleData
          .filter((row: any) => (row.deposit_cases || 0) > 0)
          .map((row: any) => row.userkey)
          .filter(Boolean)
      )
      activeMember = activeMemberSet.size

      // 2. FINANCIAL AGGREGATES
      depositAmount = blueWhaleData.reduce((sum: number, row: any) => sum + (parseFloat(row.deposit_amount) || 0), 0)
      depositCases = blueWhaleData.reduce((sum: number, row: any) => sum + (parseInt(row.deposit_cases) || 0), 0)
      withdrawAmount = blueWhaleData.reduce((sum: number, row: any) => sum + (parseFloat(row.withdraw_amount) || 0), 0)
      withdrawCases = blueWhaleData.reduce((sum: number, row: any) => sum + (parseInt(row.withdraw_cases) || 0), 0)
      addTransaction = blueWhaleData.reduce((sum: number, row: any) => sum + (parseFloat(row.add_transaction) || 0), 0)
      deductTransaction = blueWhaleData.reduce((sum: number, row: any) => sum + (parseFloat(row.deduct_transaction) || 0), 0)
      bonusAmount = blueWhaleData.reduce((sum: number, row: any) => sum + (parseFloat(row.bonus) || 0) + (parseFloat(row.add_bonus) || 0), 0)
      
      // CALCULATE GGR & NET PROFIT (sesuai KPI Comparison logic)
      grossGamingRevenue = depositAmount - withdrawAmount  // GGR = Deposit - Withdraw
      netProfit = (depositAmount + addTransaction) - (withdrawAmount + deductTransaction)  // Net Profit
      
      console.log('‚úÖ [BP Data API] Raw Aggregated KPIs:', {
        activeMember,
        grossGamingRevenue,
        netProfit
      })
    }

    // 3. NEW REGISTER & NEW DEPOSITOR (same for both modes)
    const newRegister = newRegisterData.reduce((sum: number, row: any) => sum + (parseInt(row.new_register) || 0), 0)
    const newDepositor = newRegisterData.reduce((sum: number, row: any) => sum + (parseInt(row.new_depositor) || 0), 0)

    // 4. PURE ACTIVE = Active Member - New Depositor
    const pureActive = activeMember - newDepositor

    // 5. DERIVED KPIs (same for both modes)
    const atv = depositCases > 0 ? depositAmount / depositCases : 0
    const pf = activeMember > 0 ? depositCases / activeMember : 0
    const ggrUser = activeMember > 0 ? netProfit / activeMember : 0  // ‚úÖ GGR User = Net Profit / Active Member
    const daUser = activeMember > 0 ? depositAmount / activeMember : 0
    const bonusUsageRate = activeMember > 0 ? bonusAmount / activeMember : 0
    const winRate = depositAmount > 0 ? grossGamingRevenue / depositAmount : 0
    const withdrawalRate = depositCases > 0 ? withdrawCases / depositCases : 0

    // 6. TARGET DATA
    const targetGGR = targetData?.target_ggr || 0
    const targetDepositAmount = targetData?.target_deposit_amount || 0
    const targetDepositCases = targetData?.target_deposit_cases || 0
    const targetActiveMember = targetData?.target_active_member || 0
    const forecastGGR = targetData?.forecast_ggr || 0

    // 7. TARGET ACHIEVE RATE
    const targetAchieveRate = targetGGR > 0 ? (grossGamingRevenue / targetGGR) * 100 : 0

    // 8. CHURN, RETENTION, REACTIVATION CALCULATION
    let memberMetrics
    
    if (isDateRange && startDate && endDate) {
      // ‚úÖ DAILY MODE: Already calculated in MV, use those values
      console.log('‚úÖ [BP Data API] Using cohort metrics from bp_daily_summary_myr (DAILY MODE)')
      memberMetrics = {
        retentionMember,
        reactivationMember,
        churnMember,
        retentionRate: (retentionMember + churnMember) > 0 ? (retentionMember / (retentionMember + churnMember)) * 100 : 0,
        churnRate: (retentionMember + churnMember) > 0 ? (churnMember / (retentionMember + churnMember)) * 100 : 0,
        reactivationRate: (reactivationMember + retentionMember) > 0 ? (reactivationMember / (reactivationMember + retentionMember)) * 100 : 0
      }
      console.log('‚úÖ [BP Data API] MV Cohort Metrics:', memberMetrics)
    } else {
      // ‚úÖ QUARTERLY MODE: Calculate from master table
      console.log('üîÑ [BP Data API] Calculating churn, retention, reactivation from blue_whale_myr (QUARTERLY MODE)...')
      
      memberMetrics = await calculateMemberMetrics({
        year: parseInt(year),
        quarter,
        isDateRange,
        startDate: startDate || '',
        endDate: endDate || '',
        line,
        quarterMonths,
        activeMemberCurrent: activeMember,
        newDepositor
      })
      
      console.log('üîÑ [BP Data API] Calculated Member metrics:', memberMetrics)
    }

    // ========================================
    // STEP 5: PREPARE CHART DATA
    // ========================================
    console.log('üìä [BP Data API] Preparing chart data...')
    
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    const sortedQuarters = ['Q1', 'Q2', 'Q3', 'Q4']
    
    let ggrTrend: any, depositAmountVsCases: any, withdrawAmountVsCases: any, winrateVsWithdrawRate: any, bonusUsageRateChart: any, brandGGRContribution: any, retentionVsChurnChart: any, activationRateChart: any, forecastQ4GGR: any, customerFlow: any
    
    // ========================================
    // DAILY MODE: Group by DATE
    // ========================================
    console.log('üîç [BP Data API] Chart prep decision point:', { 
      isDateRange, 
      hasStartDate: !!startDate, 
      hasEndDate: !!endDate,
      startDate,
      endDate,
      blueWhaleDataRows: blueWhaleData.length 
    })
    
    if (isDateRange && startDate && endDate) {
      console.log('üìä [BP Data API] ‚úÖ Preparing DAILY chart data from MV (bp_daily_summary_myr line=ALL)...')
      
      console.log('üìä [BP Data API] MV Daily chart data:', { 
        totalRows: mvDailyChartData.length,
        firstDate: mvDailyChartData[0]?.date,
        lastDate: mvDailyChartData[mvDailyChartData.length - 1]?.date 
      })
      
      // CHART 1: GGR Trend (Daily) - dari MV aggregated line='ALL'
      ggrTrend = mvDailyChartData.map((row: any) => ({
        month: new Date(row.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
        ggr: parseFloat(row.ggr) || 0
      }))
      
      // CHART 2: Deposit Amount vs Cases (Daily) - dari MV
      depositAmountVsCases = mvDailyChartData.map((row: any) => ({
        month: new Date(row.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
        amount: parseFloat(row.deposit_amount) || 0,
        cases: parseInt(row.deposit_cases) || 0
      }))
      
      // CHART 3: Withdraw Amount vs Cases (Daily) - dari MV
      withdrawAmountVsCases = mvDailyChartData.map((row: any) => ({
        month: new Date(row.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
        amount: parseFloat(row.withdraw_amount) || 0,
        cases: parseInt(row.withdraw_cases) || 0
      }))
      
      // CHART 4: Winrate vs Withdraw Rate (Daily) - dari MV
      winrateVsWithdrawRate = mvDailyChartData.map((row: any) => ({
        month: new Date(row.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
        winrate: parseFloat(row.winrate) || 0,
        withdrawalRate: parseFloat(row.withdrawal_rate) || 0
      }))
      
      // ‚úÖ CHART 5, 7, 8: Bonus Usage, Retention/Churn, Activation - PER BRAND (QUERY LANGSUNG blue_whale_myr)
      console.log('üìä [BP Data API] Calculating PER-BRAND charts from blue_whale_myr (NOT MV)...')
      
      // Query blue_whale_myr GROUP BY line untuk per-brand analysis
      let perBrandQuery = supabase
        .from('blue_whale_myr')
        .select('line, deposit_amount, withdraw_amount, bonus, add_bonus, valid_amount, userkey, first_deposit_date')
        .eq('currency', 'MYR')
        .gte('date', startDate)
        .lte('date', endDate)
        .neq('line', 'ALL')
        .not('line', 'is', null)
      
      const { data: perBrandData, error: perBrandError } = await perBrandQuery
      
      if (perBrandError) {
        console.error('‚ùå [BP Data API] Error fetching per-brand data:', perBrandError)
      }
      
      console.log('üìä [BP Data API] Per-brand raw data:', perBrandData?.length || 0, 'rows')
      
      // Group by brand
      const brandMetrics: Record<string, any> = {}
      
      perBrandData?.forEach((row: any) => {
        const brand = row.line?.trim()
        if (!brand) return
        
        if (!brandMetrics[brand]) {
          brandMetrics[brand] = {
            depositAmount: 0,
            withdrawAmount: 0,
            bonusAmount: 0,
            validAmount: 0,
            activeUsers: new Set(),
            newDepositors: new Set()
          }
        }
        
        brandMetrics[brand].depositAmount += parseFloat(row.deposit_amount) || 0
        brandMetrics[brand].withdrawAmount += parseFloat(row.withdraw_amount) || 0
        brandMetrics[brand].bonusAmount += (parseFloat(row.bonus) || 0) + (parseFloat(row.add_bonus) || 0)
        brandMetrics[brand].validAmount += parseFloat(row.valid_amount) || 0
        
        if (row.userkey) {
          brandMetrics[brand].activeUsers.add(row.userkey)
          
          // Check if new depositor (first_deposit_date dalam bulan ini)
          if (row.first_deposit_date) {
            const firstDepositDate = new Date(row.first_deposit_date)
            const rangeStart = new Date(startDate!)
            const rangeEnd = new Date(endDate!)
            
            if (firstDepositDate >= rangeStart && firstDepositDate <= rangeEnd) {
              brandMetrics[brand].newDepositors.add(row.userkey)
            }
          }
        }
      })
      
      const detectedBrands = Object.keys(brandMetrics).sort()
      console.log('üìä [BP Data API] Detected brands:', detectedBrands)
      
      // CHART 5: Bonus Usage Rate per brand
      bonusUsageRateChart = detectedBrands.map(brand => {
        const metrics = brandMetrics[brand]
        const bonusUsageRate = metrics.validAmount > 0 
          ? (metrics.bonusAmount / metrics.validAmount) * 100  // ‚úÖ MULTIPLY BY 100
          : 0
        
        return {
          brand,
          rate: bonusUsageRate
        }
      })
      
      // CHART 7: Retention vs Churn Rate per brand
      // Retention = (Active - New Depositor) / Active * 100
      // Churn = 100 - Retention
      retentionVsChurnChart = detectedBrands.map(brand => {
        const metrics = brandMetrics[brand]
        const activeMemberCount = metrics.activeUsers.size
        const newDepositorCount = metrics.newDepositors.size
        const retainedCount = activeMemberCount - newDepositorCount
        
        const retentionRate = activeMemberCount > 0
          ? (retainedCount / activeMemberCount) * 100  // ‚úÖ MULTIPLY BY 100
          : 0
        const churnRate = 100 - retentionRate  // ‚úÖ 100 - retentionRate (bukan 1 - retentionRate)
        
        return {
          brand,
          retentionRate,
          churnRate
        }
      })
      
      // CHART 8: Activation Rate per brand
      // Activation = New Depositor / Active Member * 100
      activationRateChart = detectedBrands.map(brand => {
        const metrics = brandMetrics[brand]
        const activeMemberCount = metrics.activeUsers.size
        const newDepositorCount = metrics.newDepositors.size
        
        const activationRate = activeMemberCount > 0
          ? (newDepositorCount / activeMemberCount) * 100  // ‚úÖ MULTIPLY BY 100
          : 0
        
        return {
          brand,
          rate: activationRate
        }
      })
      
      console.log('‚úÖ [BP Data API] Per-brand charts calculated:', {
        bonusUsageRate: bonusUsageRateChart.length,
        retentionVsChurn: retentionVsChurnChart.length,
        activationRate: activationRateChart.length
      })
      
      // ‚úÖ DAILY MODE: Prepare Sankey (works for both modes)
      console.log('üìä [BP Data API] Calculating brand member flows for Sankey (Daily Mode)...')
      const brandFlows = await calculateBrandMemberFlows({
        year: parseInt(year),
        quarter,
        isDateRange: true,
        startDate,
        endDate,
        quarterMonths: []
      })
      
      const detectedBrandsForSankey = Object.keys(brandFlows).sort()
      const sankeyNodes: any[] = [{ name: 'Active Member', value: activeMember }]
      
      detectedBrandsForSankey.forEach(brand => {
        sankeyNodes.push({ name: brand, value: brandFlows[brand]?.active || 0 })
      })
      
      const retainedIndex = sankeyNodes.length
      const churnedIndex = sankeyNodes.length + 1
      const totalRetained = Object.values(brandFlows).reduce((sum: number, flow: any) => sum + flow.retained, 0)
      const totalChurned = Object.values(brandFlows).reduce((sum: number, flow: any) => sum + flow.churned, 0)
      sankeyNodes.push({ name: 'Retained', value: totalRetained })
      sankeyNodes.push({ name: 'Churned', value: totalChurned })
      
      const sankeyLinks: any[] = []
      detectedBrandsForSankey.forEach((brand, index) => {
        const active = brandFlows[brand]?.active || 0
        if (active > 0) sankeyLinks.push({ source: 0, target: index + 1, value: active })
      })
      
      detectedBrandsForSankey.forEach((brand, index) => {
        const retained = brandFlows[brand]?.retained || 0
        const churned = brandFlows[brand]?.churned || 0
        if (retained > 0) sankeyLinks.push({ source: index + 1, target: retainedIndex, value: retained })
        if (churned > 0) sankeyLinks.push({ source: index + 1, target: churnedIndex, value: churned })
      })
      
      customerFlow = {
        nodes: sankeyNodes,
        links: sankeyLinks
      }
      
      // ‚úÖ Set dummy/empty for quarterly-only charts
      brandGGRContribution = []
      forecastQ4GGR = {
        categories: [],
        series: []
      }
      
      console.log('‚úÖ [BP Data API] Daily chart data prepared:', {
        ggrTrend: ggrTrend.length,
        depositAmountVsCases: depositAmountVsCases.length,
        withdrawAmountVsCases: withdrawAmountVsCases.length
      })
    } 
    // ========================================
    // QUARTERLY MODE: Group by QUARTER
    // ========================================
    else {
      console.log('üìä [BP Data API] ‚ö†Ô∏è Preparing QUARTERLY chart data from MV...')
      console.log('üìä [BP Data API] Why quarterly? isDateRange=' + isDateRange + ', startDate=' + startDate + ', endDate=' + endDate)
      
      // Convert MV monthly data to month name mapping
      const mvDataByMonth: Record<string, any> = {}
      
      mvFullYearData.forEach((row: any) => {
        const monthNum = row.month as number
        const monthName = monthNames[monthNum - 1]
        if (monthName) {
          mvDataByMonth[monthName] = row
        }
      })
      
      const sortedMonthsFullYear = Object.keys(mvDataByMonth).sort((a, b) => monthNames.indexOf(a) - monthNames.indexOf(b))
      console.log(`üìÖ [BP Data API] MV full year months available: ${sortedMonthsFullYear.length}`)
      
      // Group QUARTER-SPECIFIC data by month
      const dataByMonth: Record<string, any[]> = {}
      blueWhaleData.forEach((row: any) => {
        const month = row.month || 'Unknown'
        if (!dataByMonth[month]) {
          dataByMonth[month] = []
        }
        dataByMonth[month].push(row)
      })
      let sortedMonths = Object.keys(dataByMonth).sort((a, b) => monthNames.indexOf(a) - monthNames.indexOf(b))
      console.log(`üìÖ [BP Data API] Quarter-specific months: ${sortedMonths.join(', ')}`)
    
    // ========================================
    // AGGREGATE MV DATA BY QUARTER (for 5 charts)
    // ========================================
    const getQuarterFromMonth = (month: string): string => {
      const quarterMap: Record<string, string> = {
        'January': 'Q1', 'February': 'Q1', 'March': 'Q1',
        'April': 'Q2', 'May': 'Q2', 'June': 'Q2',
        'July': 'Q3', 'August': 'Q3', 'September': 'Q3',
        'October': 'Q4', 'November': 'Q4', 'December': 'Q4'
      }
      return quarterMap[month] || 'Q1'
    }
    
    // Group MV monthly data by quarter (sum aggregates)
    const mvDataByQuarter: Record<string, any> = {}
    sortedMonthsFullYear.forEach(month => {
      const quarter = getQuarterFromMonth(month)
      const monthData = mvDataByMonth[month]
      
      if (!mvDataByQuarter[quarter]) {
        mvDataByQuarter[quarter] = {
          deposit_amount: 0,
          withdraw_amount: 0,
          deposit_cases: 0,
          withdraw_cases: 0
        }
      }
      
      // Sum monthly aggregates to get quarterly totals
      mvDataByQuarter[quarter].deposit_amount += parseFloat(monthData.deposit_amount) || 0
      mvDataByQuarter[quarter].withdraw_amount += parseFloat(monthData.withdraw_amount) || 0
      mvDataByQuarter[quarter].deposit_cases += parseInt(monthData.deposit_cases) || 0
      mvDataByQuarter[quarter].withdraw_cases += parseInt(monthData.withdraw_cases) || 0
    })
    
      // CHART 1: GGR Trend (Quarterly) - FROM MV
      ggrTrend = sortedQuarters.map(quarter => {
        const quarterData = mvDataByQuarter[quarter]
        const depositAmt = quarterData ? quarterData.deposit_amount : 0
        const withdrawAmt = quarterData ? quarterData.withdraw_amount : 0
        const ggr = depositAmt - withdrawAmt
        return {
          month: quarter,
          ggr
        }
      })
      
      // CHART 2 & 3: Deposit/Withdraw Amount vs Cases (Quarterly) - FROM MV
      depositAmountVsCases = sortedQuarters.map(quarter => {
        const quarterData = mvDataByQuarter[quarter]
        return {
          month: quarter,
          amount: quarterData ? quarterData.deposit_amount : 0,
          cases: quarterData ? quarterData.deposit_cases : 0
        }
      })
      
      withdrawAmountVsCases = sortedQuarters.map(quarter => {
        const quarterData = mvDataByQuarter[quarter]
        return {
          month: quarter,
          amount: quarterData ? quarterData.withdraw_amount : 0,
          cases: quarterData ? quarterData.withdraw_cases : 0
        }
      })
      
      // CHART 4: Winrate vs Withdraw Rate (Quarterly) - FROM MV
      winrateVsWithdrawRate = sortedQuarters.map(quarter => {
        const quarterData = mvDataByQuarter[quarter]
        const depositAmt = quarterData ? quarterData.deposit_amount : 0
        const withdrawAmt = quarterData ? quarterData.withdraw_amount : 0
        const ggr = depositAmt - withdrawAmt
        const withdrawCases = quarterData ? quarterData.withdraw_cases : 0
        const depositCases = quarterData ? quarterData.deposit_cases : 0
        
        const winrate = depositAmt > 0 ? (ggr / depositAmt) * 100 : 0
        const withdrawRate = depositCases > 0 ? (withdrawCases / depositCases) * 100 : 0
        
        return {
          month: quarter,  // Use quarter label (Q1, Q2, Q3, Q4)
          winrate,
          withdrawalRate: withdrawRate
        }
      })
      
      // CHART 5: Bonus Usage Rate per Brand
      const dataByBrand: Record<string, any[]> = {}
      blueWhaleData.forEach((row: any) => {
        const brand = row.line
        if (brand && brand.trim()) {  // ‚úÖ Filter empty/null brands
          if (!dataByBrand[brand]) {
            dataByBrand[brand] = []
          }
          dataByBrand[brand].push(row)
        }
      })
      
      const detectedBrands = Object.keys(dataByBrand).sort()
      console.log(`üìä [Charts] Auto-detected brands from data: ${detectedBrands.join(', ')}`)
      
      bonusUsageRateChart = detectedBrands.map(brand => {
        const brandData = dataByBrand[brand] || []  // ‚úÖ Add fallback (defensive)
        
        // Active Member for this brand
        const activeMemberBrand = new Set(
          brandData
            .filter((row: any) => (row.deposit_cases || 0) > 0)
            .map((row: any) => row.userkey)
            .filter(Boolean)
        ).size
        
        // Bonus for this brand
        const bonusBrand = brandData.reduce((sum: number, row: any) => sum + (parseFloat(row.bonus) || 0) + (parseFloat(row.add_bonus) || 0), 0)
        
        const rate = activeMemberBrand > 0 ? bonusBrand / activeMemberBrand : 0  // ‚úÖ FIXED: Removed * 100
        
        return {
          brand,
          rate
        }
      })
      
      // ========================================
      // QUARTERLY-ONLY CHARTS: Brand GGR, Retention, Activation, Forecast
      // ========================================
      console.log('üìä [BP Data API] Preparing QUARTERLY-ONLY charts (Brand GGR, Retention, Activation, Forecast)...')
      
      // CHART 6: Brand GGR Contribution (Stacked Bar - Per Quarter Per Brand) - FROM MV
      brandGGRContribution = sortedQuarters.map(quarter => {
      const result: any = { month: quarter }
      
      // Get month numbers for this quarter
      const quarterMonthMap: Record<string, number[]> = {
        'Q1': [1, 2, 3],
        'Q2': [4, 5, 6],
        'Q3': [7, 8, 9],
        'Q4': [10, 11, 12]
      }
      const monthsInQuarter = quarterMonthMap[quarter] || []
      
      // Filter MV data for this quarter and group by brand
      const brandTotals: Record<string, { deposit: number; withdraw: number }> = {}
      
      mvBrandsData.forEach((row: any) => {
        const monthNum = row.month as number
        const brand = row.line as string
        
        if (monthsInQuarter.includes(monthNum) && brand) {
          if (!brandTotals[brand]) {
            brandTotals[brand] = { deposit: 0, withdraw: 0 }
          }
          brandTotals[brand].deposit += parseFloat(row.deposit_amount) || 0
          brandTotals[brand].withdraw += parseFloat(row.withdraw_amount) || 0
        }
      })
      
      // Calculate GGR per brand
      Object.keys(brandTotals).forEach(brand => {
        const ggr = brandTotals[brand].deposit - brandTotals[brand].withdraw
        result[brand] = ggr
      })
      
      return result
    })
    
    // CHART 7 & 8: Retention Rate & Activation Rate (Per Brand)
    // Group new_register data by brand
    const newRegisterByBrand: Record<string, any[]> = {}
    newRegisterData.forEach((row: any) => {
      const brand = row.line
      if (brand && brand.trim()) {  // ‚úÖ Filter empty/null brands
        if (!newRegisterByBrand[brand]) {
          newRegisterByBrand[brand] = []
        }
        newRegisterByBrand[brand].push(row)
      }
    })
    
      // CHART 7: Retention vs Churn Rate (Per Brand - Double Bar)
      retentionVsChurnChart = detectedBrands.map(brand => {
      const brandData = dataByBrand[brand] || []  // ‚úÖ Add fallback
      const newRegBrand = newRegisterByBrand[brand] || []
      
      // Active Member for this brand
      const activeMemberBrand = new Set(
        brandData
          .filter((row: any) => (row.deposit_cases || 0) > 0)
          .map((row: any) => row.userkey)
          .filter(Boolean)
      ).size
      
      // New Depositor for this brand
      const newDepositorBrand = newRegBrand.reduce((sum: number, row: any) => sum + (parseInt(row.new_depositor) || 0), 0)
      
      // Retention Rate = (Active Member - New Depositor) / Active Member * 100
      const retentionRate = activeMemberBrand > 0 ? ((activeMemberBrand - newDepositorBrand) / activeMemberBrand) * 100 : 0
      
      // Churn Rate = 100 - Retention Rate
      const churnRate = 100 - retentionRate
      
      return {
        brand,
        retentionRate,
        churnRate
      }
    })
    
      activationRateChart = detectedBrands.map(brand => {
      const newRegBrand = newRegisterByBrand[brand] || []  // ‚úÖ Add fallback
      const brandData = dataByBrand[brand] || []
      
      // Total new register
      const totalNewReg = newRegBrand.reduce((sum: number, row: any) => sum + (parseInt(row.new_register) || 0), 0)
      
      // New depositor (activated)
      const newDepositor = newRegBrand.reduce((sum: number, row: any) => sum + (parseInt(row.new_depositor) || 0), 0)
      
      // Activation Rate = New Depositor / Total New Register * 100
      const rate = totalNewReg > 0 ? (newDepositor / totalNewReg) * 100 : 0
      
      return {
        brand,
        rate
      }
    })
    
    // ========================================
    // CHART: FORECAST Q4 GGR (Quarterly)
    // ========================================
      const forecastCategories = sortedQuarters
      const actualGGRData = sortedQuarters.map(quarter => {
        const ggrForQuarter = ggrTrend.find((g: any) => g.month === quarter)
        return ggrForQuarter ? ggrForQuarter.ggr : 0
      })
    
    // USE TARGET FROM DATABASE (bp_target table)
    const targetGGRValue = targetData?.target_ggr || 0
    const targetGGRData = sortedQuarters.map(() => targetGGRValue)
    
    // ‚úÖ DYNAMIC FORECAST CALCULATION USING LINEAR REGRESSION
    // Collect ALL historical quarters with actual data (completed quarters only)
    const historicalData: { x: number; y: number }[] = []
    sortedQuarters.forEach((q, i) => {
      const ggrValue = actualGGRData[i]
      // Only include quarters with substantial data (not partial/incomplete quarters)
      // We consider a quarter complete if it has data
      if (ggrValue > 0) {
        historicalData.push({ x: i + 1, y: ggrValue })  // x = quarter number (1,2,3,4)
      }
    })
    
    console.log('üìä [Forecast] Historical Data Points:', historicalData)
    
    // Calculate forecast for ALL quarters using linear regression
    const forecastGGRData = sortedQuarters.map((quarter, index) => {
      // Need at least 2 historical data points to forecast
      if (historicalData.length < 2) {
        return 0
      }
      
      // LINEAR REGRESSION: y = mx + b
      const n = historicalData.length
      const sumX = historicalData.reduce((sum: number, d: any) => sum + d.x, 0)
      const sumY = historicalData.reduce((sum: number, d: any) => sum + d.y, 0)
      const sumXY = historicalData.reduce((sum: number, d: any) => sum + (d.x * d.y), 0)
      const sumX2 = historicalData.reduce((sum: number, d: any) => sum + (d.x * d.x), 0)
      
      // Calculate slope (m) and intercept (b)
      const denominator = (n * sumX2 - sumX * sumX)
      if (denominator === 0) {
        // Avoid division by zero - return average if slope can't be calculated
        const avgY = sumY / n
        return avgY
      }
      
      const m = (n * sumXY - sumX * sumY) / denominator
      const b = (sumY - m * sumX) / n
      
      // Predict for this quarter (index + 1)
      const forecastValue = m * (index + 1) + b
      
      return forecastValue > 0 ? forecastValue : 0
    })
    
    console.log('üìä [Forecast GGR] Actual Data:', actualGGRData)
    console.log('üìä [Forecast GGR] Forecast Data:', forecastGGRData)
    console.log('üìä [Forecast GGR] Target Data:', targetGGRData)
    
      // ‚úÖ SHOW ALL 3 LINES FOR COMPARISON:
      // - Actual GGR (Blue): Real data from database
      // - Target GGR (Green): Target from bp_target table
      // - Forecast GGR (Orange): Predicted using Linear Regression
      forecastQ4GGR = {
      categories: forecastCategories,
      series: [
        { name: 'Actual GGR', data: actualGGRData, color: '#3B82F6' },
        { name: 'Target GGR', data: targetGGRData, color: '#10b981' },
        { name: 'Forecast GGR', data: forecastGGRData, color: '#F97316' }
      ]
    }
    
      console.log('‚úÖ [BP Data API] Quarterly-only charts prepared')
    }
    
    // ========================================
    // CHART: SANKEY DIAGRAM (Active Member ‚Üí Brands ‚Üí Retained/Churned)
    // For QUARTERLY mode only (Daily mode already has Sankey)
    // ========================================
    if (!isDateRange || !startDate || !endDate) {
      console.log('üìä [BP Data API] Calculating brand member flows for Sankey (Quarterly Mode)...')
      const brandFlows = await calculateBrandMemberFlows({
      year: parseInt(year),
      quarter,
      isDateRange,
      startDate: startDate || '',
      endDate: endDate || '',
      quarterMonths
    })
    
    // Calculate totals for validation
    const totalActiveBrands = Object.values(brandFlows).reduce((sum: number, flow: any) => sum + flow.active, 0)
    const totalRetained = Object.values(brandFlows).reduce((sum: number, flow: any) => sum + flow.retained, 0)
    const totalChurned = Object.values(brandFlows).reduce((sum: number, flow: any) => sum + flow.churned, 0)
    
    console.log('üìä [BP Data API] Sankey validation:', {
      activeMemberTotal: activeMember,
      totalActiveBrands,
      totalRetained,
      totalChurned,
      brandFlows
    })
    
    // VALIDATION: If total brands > active members, there's a data issue
    // In this case, we'll normalize or use actual active member as the source
    
    // Extract brands from brandFlows object (sorted for consistency)
    const detectedBrandsForSankey = Object.keys(brandFlows).sort()
    
    // Build nodes DYNAMICALLY based on detected brands
    const sankeyNodes: any[] = [
      { name: 'Active Member', value: activeMember }
    ]
    
    // Add brand nodes dynamically
    detectedBrandsForSankey.forEach(brand => {
      sankeyNodes.push({ 
        name: brand, 
        value: brandFlows[brand]?.active || 0 
      })
    })
    
    // Add final nodes (Retained & Churned)
    const retainedIndex = sankeyNodes.length
    const churnedIndex = sankeyNodes.length + 1
    sankeyNodes.push({ name: 'Retained', value: totalRetained })
    sankeyNodes.push({ name: 'Churned', value: totalChurned })
    
    const sankeyLinks: any[] = []
    
    // Flow: Active Member ‚Üí Brands
    detectedBrandsForSankey.forEach((brand, index) => {
      const active = brandFlows[brand]?.active || 0
      if (active > 0) {
        sankeyLinks.push({ source: 0, target: index + 1, value: active })
      }
    })
    
    // Flow: Brands ‚Üí Retained/Churned (use correct indices)
    detectedBrandsForSankey.forEach((brand, index) => {
      const retained = brandFlows[brand]?.retained || 0
      const churned = brandFlows[brand]?.churned || 0
      
      if (retained > 0) {
        sankeyLinks.push({ source: index + 1, target: retainedIndex, value: retained })
      }
      if (churned > 0) {
        sankeyLinks.push({ source: index + 1, target: churnedIndex, value: churned })
      }
    })
    
      customerFlow = {
        nodes: sankeyNodes,
        links: sankeyLinks
      }
      
      console.log('‚úÖ [BP Data API] Sankey for Quarterly mode prepared')
    }
    
    const chartData = {
      ggrTrend,
      depositAmountVsCases,
      withdrawAmountVsCases,
      winrateVsWithdrawRate,
      bonusUsageRate: bonusUsageRateChart,
      brandGGRContribution,
      retentionVsChurn: retentionVsChurnChart,
      activationRate: activationRateChart,
      forecastQ4GGR,
      customerFlow
    }

    // ========================================
    // STEP 6: RETURN RESPONSE
    // ========================================
    const totalTime = Date.now() - startTime
    console.log(`‚úÖ [BP Data API] Success! Total time: ${totalTime}ms`)

    return NextResponse.json({
      success: true,
      data: {
        kpis: {
          // ROW 1: Main KPI Cards
          targetAchieveRate,
          currentGGR: grossGamingRevenue,
          targetGGR,
          activeMember,
          pureActive,
          
          // ROW 1: Transaction Metrics (Dual KPI)
          atv,
          purchaseFrequency: pf,
          
          // ROW 1: User Value Metrics (Dual KPI)
          ggrUser,
          daUser,
          
          // Additional Financial KPIs
          netProfit,
          depositCases,
          depositAmount,
          withdrawCases,
          withdrawAmount,
          
          // Rate KPIs
          bonusUsageRate,
          winRate,
          withdrawalRate,
          
          // Member Metrics
          churnMember: memberMetrics.churnMember,
          retentionMember: memberMetrics.retentionMember,
          reactivationMember: memberMetrics.reactivationMember,
          churnRate: memberMetrics.churnRate,
          retentionRate: memberMetrics.retentionRate,
          reactivationRate: memberMetrics.reactivationRate,
          
          // Registration
          newRegister,
          newDepositor,
          
          // Activation Rate (New Depositor / New Register)
          activationRate: newRegister > 0 ? (newDepositor / newRegister) * 100 : 0,
          
          // Target Data
          targetDepositAmount,
          targetDepositCases,
          targetActiveMember,
          forecastGGR
        },
        chartData,
        metadata: {
          year,
          quarter,
          isDateRange,
          startDate: isDateRange ? startDate : null,
          endDate: isDateRange ? endDate : null,
          line,
          queryTimeMs: queryTime,
          totalTimeMs: totalTime,
          dataSource: {
            blueWhaleRows: blueWhaleData.length,
            newRegisterRows: newRegisterData.length,
            hasTargetData: !!targetData
          }
        }
      }
    })

  } catch (error) {
    console.error('‚ùå [BP Data API] Error:', error)
    return NextResponse.json(
      { 
        success: false,
        error: 'Failed to fetch business performance data',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}


